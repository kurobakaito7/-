# 一、浏览器安全

## XSS攻击

## CSRF攻击

## 有哪些可能前端安全的问题
+ 跨站脚本（Cross-Site Scripting, XSS）：⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；
+ iframe的滥用：iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
+ 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）：指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击
+ 恶意第三方库：⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。

## 网络劫持有哪几种，如何防范？
网络劫持分为两种：
+ （1）DNS劫持： (输⼊京东被强制跳转到淘宝这就属于dns劫持)
      + DNS强制解析：通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
      + 302跳转的方式：通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容
+ （2）HTTP劫持：(访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)

DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。

# 二、进程与线程
1. 概念
   从本质上说，进程和线程都是 CPU 工作时间片的一个描述：
   + 进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
   + 线程是进程中的更小单位，描述了执行一段指令所需的时间。
 + **进程是资源分配的最小单位，线程是CPU调度的最小单位**

2. 虚拟内存
   **进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统的角度来看，虚拟内存即交换文件；从处理器角度来看，虚拟内存即虚拟地址空间**
   如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。

3. 浏览器进程
   + 浏览器主进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
   + 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
   + GPU进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
   + 多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
   + 多个插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
所以，**打开一个网页，最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：
+ 更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
+ 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

4. 浏览器渲染进程的线程有哪些？
   浏览器的渲染进程的线程总共有五种：
      1. **GUI渲染线程** 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
      > 注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
      2. **JS引擎线程** JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；
      > 注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。
      3. **事件触发线程** 事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；
      4. **定时器触发进程** 定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；
      5. **异步http请求线程**
         + XMLHttpRequest连接后通过浏览器新开一个线程请求；
         + 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

5. 进程之间的通信方式
   1. 管道通信
   2. 消息队列通信
   3. 信号量通信
   4. 信号通信
   5. 共享内存通信
   6. 套接字通信
6. 孤儿进程和僵尸进程
   + 孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
   + 僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
7. 死锁产生的原因？如何解决死锁？
   所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
   系统中的资源可以分为两类：
      + 可剥夺资源：指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
      + 不可剥夺资源：当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

  **产生死锁的原因：**
  + 竞争资源：竞争不可剥夺资源或者竞争临时资源
  + 进程间推进顺序非法

  **产生死锁的必要条件：**
  + 互斥条件
  + 请求和保持条件
  + 不剥夺条件
  + 环路等待条件

  **预防死锁的方法：**
  + 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
  + 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
  + 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
  + 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

8. 如何实现浏览器内多个标签页之间的通信
   实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：
   + **使用 websocket 协议**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
   + **使用 ShareWorker 的方式**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
   + **使用 localStorage 的方式**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
   + **使用 postMessage 方法**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。

9. 对Service Worker的理解
    Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为**HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

    Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

# 三、浏览器缓存
1. 对浏览器缓存机制的理解
   ### 浏览器缓存的全过程：
   + 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
   + 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；
   + 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
   + 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
   + 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；
2. 强缓存和协商缓存的区别
   1. 强缓存
   使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。
   强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。
      1. 服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。
      2. Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，
   一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。
      > Cache-conctrol中的可设置的字段中no-cache和no-store很容易混淆：
      + no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
      + no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
   2. 协商缓存
      如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。
      命中协商缓存的条件：
      + `max-age=xxx` 过期了
      + 值为 `no-cache`
      使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。
   #### 总结
   强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

3. 为什么需要浏览器缓存？
   所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。
   对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。
   #### 优点
      + 减少了服务器的负担，提高了网站的性能
      + 加快了客户端网页的加载速度
      + 减少了多余网络数据传输 

# 四、浏览器组成

# 五、浏览器渲染原理

## 浏览器的渲染过程
+ 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
+ 然后对 CSS 进行解析，生成 CSSOM 规则树。
+ 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
+ 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
+ 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

注意： 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

## 渲染优化

1. 针对JavaScript： JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此可以对JavaScript的加载方式进行改变，来进行优化：
   1. 尽量将JavaScript文件放在body的最后
   2. body中间尽量不要写 `<script>` 标签
   3. `<script>` 标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 `async` 属性和 `defer` 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。
2. 针对CSS：使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：
   + link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
   + @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
   + style：GUI直接渲染
 + 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。
3. 针对DOM树、CSSOM树：
   + HTML文件的代码层级尽量不要太深
   + 使用语义化的标签，来避免不标准语义化的特殊处理
   + 减少CSSD代码的层级，因为选择器是从左向右进行解析的
4. 减少回流与重绘：
   + 操作DOM时，尽量在低层级的DOM节点进行操作
   + 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
   + 使用CSS的表达式
   + 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
   + 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
   + 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
   + 将元素先设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的DOM操作不会引发回流和重绘。
   + 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**

浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。

将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 阻塞渲染的情况

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。

当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。



# 六、浏览器的本地存储
1. 本地存储方式及使用场景
   1. Cookie
   2. LocalStorage
   3. SessionStorage
2. Cookie、LocalStorage、SessionStorage的区别
   + Cookie：其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。
   + SessionStorage：html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。
   + LocalStorage：html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。
  
  上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 `indexDB` 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。

## Cookie有哪些字段，作用分别是什么？
+ Name：cookie的名称
+ Value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；
+ Size： cookie的大小
+ Path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。
+ Secure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
+ Domain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
+ HTTP： 该字段包含HTTPOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。
+ Expires/Max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。

### 总结
服务器端可以使用 `Set-Cookie` 的响应头部来配置 `cookie` 信息。一条 `cookie` 包括了5个属性值 `expires、domain、path、secure、HttpOnly`。其中 `expires` 指定了 `cookie` 失效的时间，`domain` 是域名、`path`是路径，`domain` 和 `path` 一起限制了 `cookie` 能够被哪些 `url` 访问。`secure` 规定了 `cookie` 只能在确保安全的情况下传输，`HttpOnly` 规定了这个 `cookie` 只能被服务器访问，不能使用 js 脚本访问。

## cookie的二级作用域共享
Cookie的二级作用域共享主要指的是在同一个顶级域名（也称为一级域名）下的不同二级域名之间共享Cookie。这种共享机制允许网站在不同子域间传递用户信息，如登录状态、用户偏好等，从而提升用户体验和数据一致性。

### 前提条件
+ 共享的二级域名必须解析于同一个顶级域名之下。
+ 例如，`a.example.com` 和 `b.example.com` 可以共享Cookie，因为它们都解析于 `example.com` 这个顶级域名。

### 实现方式
1.  设置Cookie的 `domain` 属性
    + 在设置Cookie时，通过domain属性指定Cookie的作用域。要实现二级域名间的共享，应将domain属性设置为顶级域名，但注意要去掉前面的“www”等子域部分，直接以点（.）开头。
    + 例如，在a.example.com下设置Cookie时，可以这样写：document.cookie = "name=value; domain=.example.com; path=/";
    + 这样，这个Cookie就可以在example.com下的所有二级域名（如b.example.com）中被访问到。
2. 注意`path`属性的设置
   + path属性指定了Cookie可以访问的URL路径。如果设置为/，则表示Cookie可以访问该域名下的所有路径。
   + 在大多数情况下，为了实现最大范围的共享，path属性应设置为/。
3. 安全性考虑
   + 跨域共享Cookie可能带来安全风险，因为它允许不同子域间访问用户的敏感信息。
   + 因此，在设置Cookie时，应谨慎考虑是否需要跨域共享，并采取适当的安全措施（如HTTPS、HttpOnly、Secure标志等）来保护Cookie不被恶意访问。
+ 注意事项
   + 非顶级域名（如三级域名或更深层次的子域）不能直接设置为其他二级域名的Cookie域，否则Cookie无法生成。
   + 顶级域名只能设置其自己的Cookie域，不能设置为二级域名或更低层次的子域。
   + 未指定domain属性的Cookie默认只能在其所在的域名下访问。


## 不在同一个主域名下的两个页面，怎样能够拿到对方的cookie

1. 设置Cookie的`Domain`属性
2. CORS 和 `Access-Control-Allow-Credentials`
   在服务器端设置CORS相关的HTTP响应头，包括`Access-Control-Allow-Origin`和`Access-Control-Allow-Credentials`。将`Access-Control-Allow-Credentials`设置为`true`，允许跨域请求携带认证信息（包括Cookie）。
3. JSONP（不推荐）
4. 反向代理
5. 使用第三方Cookie
   + 原理：如果两个页面都使用了来自同一个第三方域名的Cookie，那么它们就可以通过该第三方域名下的Cookie实现跨域共享。
   + 注意：然而，现在许多浏览器都默认禁止了第三方Cookie的使用，因此这种方法的可行性受到了很大的限制。


# 七、浏览器同源策略
1. 什么是同源策略？
   **同源策略**指的是协议、域名、端口三者必须保持一致。
   跨域问题其实就是浏览器的同源策略造成的。
   > 同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。
   同源政策主要限制了三个方面：
      + 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
      + 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
      + 当前域下 ajax 无法发送跨域请求。
2. 如何解决跨域问题
   1. CORS（跨域资源共享）：在服务器端设置响应头，允许跨域请求。通过在响应头中添加特定的 CORS 头部。
      + 如果是简单请求，在服务器内，至少要设置字段：`Access-Control-Allow-Origin`
      + 非简单请求：对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。至少需要设置的字段：`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`
      #### CORS中传递Cookie
      在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：
         + 在请求中设置 `withCredentials`：默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.
         + `Access-Control-Allow-Credentials` 设置为 true
         + `Access-Control-Allow-Origin` 设置为非`*`
   2. JSONP
      jsonp的原理就是利用 `<script>` 标签没有跨域限制，通过 `<script>` 标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。
      #### 缺点：
         + 具有局限性，仅支持get方法
         + 不安全，易遭受XSS攻击
   3. WebSocket协议跨域
      WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。其本身就支持跨域。
   4. postMessage跨域
      postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
         + 页面和其打开的新窗口的数据传递
         + 多窗口之间消息传递
         + 页面与嵌套的iframe消息传递
         + 上面三个场景的跨域数据传递
   5. nodejs中间件代理跨域
      node中间件实现跨域代理，通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。
      1. **非vue框架的跨域：** 使用node + express + http-proxy-middleware搭建一个proxy服务器。
      2. **vue框架的跨域：** node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。
         webpack.config.js配置：
         ```js
         module.exports = {
             entry: {},
             module: {},
             ...
             devServer: {
                 historyApiFallback: true,
                 proxy: [{
                     context: '/login',
                     target: 'http://www.target.com:8080',  // 代理跨域目标接口
                     changeOrigin: true,// 允许跨域  
                     secure: false,  // 当代理某些https服务报错时用
                     cookieDomainRewrite: 'www.local.com'  // 可以为false，表示不修改
                 }],
                 noInfo: true
             }
         }
         ```




# 八、浏览器事件机制

## Node中的Event Loop和浏览器中的有什么区别？
Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
### 宏队列：
1. Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。
2. Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。
3. Idle/Prepare：仅供nodejs内部使用
4. Poll（轮询阶段）：
   + 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况：
   + 当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。
5. Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。
6. Close callbacks：执行一些关闭回调，比如socket.on('close', ...)等。

### 微队列：
   + nextTick
   + Promise



# 九、浏览器垃圾回收机制

## v8垃圾回收机制

V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

1. 新生代算法

新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

2. 老生代算法

老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。

## 哪些操作会造成内存泄露

1. 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。
2. 第二种情况是设置了 `setInterval` 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。
3. 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。
4. 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。

# 十、浏览器通信

## 同一窗口或标签页内的通信

1. 直接使用变量或对象：

在同一窗口或标签页内，可以直接通过变量或对象来传递数据和信息。这种方式简单直接，但仅限于同一上下文环境。

2. LocalStorage 和 SessionStorage

- LocalStorage 和 SessionStorage 是浏览器提供的本地存储机制，可以用于在同一窗口或标签页内的不同页面之间共享数据。
- 通过在一个页面中修改 LocalStorage 或 SessionStorage 中的数据，然后在其他页面中监听该数据的变化，可以实现跨页面的通信。

## 跨窗口或标签页的通信

1. window.postMessage
- HTML5 引入了 window.postMessage 方法，允许跨窗口或标签页进行通信，不论这些窗口或标签页是否同源。
- 使用 window.postMessage 方法时，需要指定目标窗口的源（origin）来确保安全通信。
- 常见的建立联系的方式包括 window.open、window.opener 和 iframe。

2. Broadcast Channel API
- Broadcast Channel API 是 HTML5 提供的一种跨页面通信的机制，允许在同一浏览器窗口下的不同标签页之间进行发布-订阅式的通信。
- 通过创建一个 BroadcastChannel 对象并指定一个唯一的通道名称，不同的标签页可以通过这个通道发送和接收消息。

3. SharedWorker
- SharedWorker 是一种特殊的 Web Worker，可以被多个浏览器标签页所共享。
- 通过 SharedWorker，不同标签页可以通过消息传递进行通信，实现跨页面的数据共享和通信。
- 需要注意的是，SharedWorker 需要在支持 SharedWorker 的浏览器中运行，而且需要在服务器环境下运行（即通过 HTTP 或 HTTPS 协议访问页面）才能正常工作。

## 跨域通信

1. WebSocket
2. CORS(跨域资源共享)
3. JSONP

## 其他通信方式

1. Cookie
2. URL参数