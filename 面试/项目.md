# NextJs

## NestJs是什么

NextJS是一款基于 React 进行 web 应用开发的框架，它以极快的应用体验而闻名，内置 Sass、Less、ES 等特性，开箱即用。SSR 只是 NextJS 的一种场景而已，它拥有4种渲染模式，我们需要为自己的应用选择正确的渲染模式：

+ Client Side Rendering (CSR)
客户端渲染，往往是一个 SPA(单页面应用)，HTML文件仅包含JS\CSS资源，不涉及页面内容，页面内容需要浏览器解析JS后二次渲染。
+ Static Site Generation (SSG)
静态页面生成，对于不需要频繁更新的静态页面内容，适合SSR，不依赖服务端。
+ Server Side Rendering (SSR)
服务端渲染，对于需要频繁更新的静态页面内容，更适合使用SSR，依赖服务端。
+ IncreIncremental Site Rendering (ISR)
增量静态生成，基于页面内容的缓存机制，仅对未缓存过的静态页面进行增量式生成，依赖服务端。

## NextJs的优缺点

### 优点：
1. 首屏加载速度快
我们的内嵌场景比较丰富，因此比较**追求页面的一个首屏体验**，NextJS 的产物类似 ` MPA（多页面应用）`，在请求页面时会对当前页面的资源进行按需加载,而不是去加载整个应用, 相对于 SPA 而言，可以实现更为极致的用户体验。
2. SEO优化好
SSR \ SSG \ ISR 支持页面内容预加载，提升了搜索引擎的友好性。
3. 内置特性易用且极致
NextJS 内置 getStaticProps、getServerSideProps、next/image、next/link、next/script等特性，充分利用该框架的这些特性，为你的用户提供更高层次的体验

### 缺点
1. 页面响应相对于SPA而言更慢
由于页面资源分页面按需加载，每次路由发生变化都需要加载新的资源，优化不够好的话，会导致页面卡顿。
2. 开发体验不够友好
开发环境下 NextJS 根据当前页面按需进行资源实时构建，影响开发及调试体验


## NextJs优化措施

+ 优化用户体验
  1. 开启 gzip 压缩
  2. 针对非首屏组件基于 `dynamic` 动态加载：
   在页面加载过程中，针对一些不可见组件，我们应该动态导入，而不是正常导入，确保只有需要该组件的场景下，才 `fetch` 对应资源, 通过 `next/dynamic`，在构建时，框架层面会帮我们进行分包
  3. `next/script` 优化 `script` 加载时： 
   `next/script` 可以帮助我们来决定 js 脚本加载的时机
  4. `next/image` 优化图片资源：
   `next/image` 可帮助我们**对图片进行压缩（尺寸 or 质量），且支持图片懒加载**，默认 `loader` 依赖 `nextjs` 内置服务，也可以通过`{loader: custom}`自定义loader
  5. next/link 预加载：
   基于 `hover` 识别用户意图，当用户 `hover` 到 `Link` 标签时，对即将跳转的页面资源进行预加载，进一步防止页面卡顿
  6. 静态内容预加载
   基于 `getStaticProps` 对不需要权限的内容进行预加载，它将在 NextJS 构建时被编译到页面中，`减少了 http 请求数量`
  7. 第三方 library 过大时，基于 `umd` 按需加载
   当第三方 library 过大时，以 `umd` 进行引入，在需要的场景下通过 `script` 进行加载。



# Websocket

## 连接建立过程

1. 建立TCP连接
2. 在建立TCP连接之后，浏览器会先通过HTTP请求来告知服务器进行协议升级，具体的做法是在带上一些特殊的请求头：
   ![alt text](./assets/image9.png)
   + `Connection: Upgrade`用于告知服务器进行协议升级
   + `Upgrade: websocket`用于告知想要升级的协议是Websocket
   + `Set-Websocket-Key`是一段随机生成的base64码，用于服务器返回响应结果时验证
3. 服务器如果支持升级成WebSocket协议，就会在响应结果中指示浏览器切换协议，具体做法如下：
   ![alt text](./assets/image10.png)
   + 根据客户端传递过来的`Set-Websocket-Key`用某个公开的算法变成另外一个字符串，放在HTTP响应的`Sec-Websocket-Accept`响应头中
   + 将响应状态码设置为`101`
   + 此时，浏览器收到服务器的响应结果之后，会同样使用公开算法将之前发送的`Set-Websocket-Key`转成另外一个字符串，与服务器返回的`Sec-Websocket-Accept`进行比较，如果一致的话就验证通过
   + 至此握手完成，WebSocket连接建立，之后就可以使用WebSocket进行通信了